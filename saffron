#!/usr/local/bin/node

/*
 * Copyright (c) 2013 Janek Priimann, janek.priimann@gmail.com
 *
 * Licensed under the terms of MIT License.
 */

var child_process = require('child_process');
var path = require('path');
var fs = require('fs');

var CONST = {
    HAXE_PATH: 'haxe',
    NPM_PATH: 'npm',
    CONFIG_NAME: 'saffron.json',
    MODE_COMPILE: 'compile',
    MODE_HELP: 'help',
    MODE_MONITOR: 'monitor',
    NODE_MODULES: [ 'connect', 'cookies', 'dustjs-linkedin', 
                    'formidable', 'generic-pool', 'mapstrace',
                    'mysql' /* @2.0.0-alpha3 */ ],
    STATUS_CRASHED: 'CRASHED',
    STATUS_EXITED: 'EXITED',
    STATUS_STARTED: 'RUNNING',
    STATUS_STOPPED: 'STOPPED',
    STATUS_BUILDING: 'BUILDING',
    STATUS_ERROR: 'ERROR',
    TYPE_CLI: 'cli',
    TYPE_API: 'api',
    TYPE_HYBRID: 'hybrid',
    TYPE_CLIENT: 'client',
    TYPE_SERVER: 'server',
    VERSION: '1.0'
};

var State = {
    apps: { },
    config: null,
    debug: true,
    root: null,
    verbose: false,
    depth: 0,
    lock: function() {
        this.depth += 1;
    },
    unlock: function() {
        this.depth -= 1;
        
        if(this.depth == 0) {
            process.stdout.write('> ');
        }
    },
    log: function(str, force) {
        if(this.verbose == true || force == true) {
            if(this.depth == 0) {
                process.stdout.write('\r');
            }
            
            process.stdout.write(str);
            
            if(this.depth == 0) {
                process.stdout.write('> ');
            }
        }
    },
    exec: function(cmd, fn, cwd) {
        this.log(cmd + '\n');
        
        return child_process.exec(cmd, { cwd: (cwd != null) ? cwd : this.root }, fn);
    },
    app: function(name) {
        var app = this.apps[name];
        var i, c;
        
        if(app == null) {
            for(i = 0, c = this.config.apps.length; i < c; i++) {
                if(this.config.apps[i].name == name) {
                    app = new Application(this.config.apps[i]);
                    this.apps[name] = app;
                    break;
                }
            }
        }
        
        return app;
    }
};

var Monitor = {
    files: { },
    findAllSubdirectories: function(dir, results) {
        var i, c, s, p, paths = fs.readdirSync(dir);
        
        for(i = 0, c = paths.length; i < c; i++) {
            if(paths[i].indexOf('.') != 0) {
                p = path.join(dir, paths[i]);
                s = fs.statSync(p);
                
                if(s != null && s.isDirectory()) {
                    results.push(p);
                    this.findAllSubdirectories(p, results);
                }
            }
        }
    },
    invalidateFn: function(p) {
        var that = this;
        
        return function(curr, prev) {
            if(curr.mtime.valueOf() != prev.mtime.valueOf() || curr.ctime.valueOf() != prev.ctime.valueOf()) {
                that.invalidate(p);
            }
        };
    },
    invalidate: function(path) {
        var i, c, s = null, f = this.files[path];
        
        if(f != null) {
            var dirs = [ path ];
            
            if(f.dir == true) {
                this.findAllSubdirectories(path, dirs);
            }
            
            for(i = 0, c = f.watchers; i < c; i++) {
                if(dirs.indexOf(f.watchers[i]) == -1) {
                    fs.unwatchFile(f.watchers[i]);
                }
            }
            
            for(i = 0, c = dirs.length; i < c; i++) {
                if(f.watchers.indexOf(dirs[i]) == -1) {
                    if(s == null) {
                        s = this.invalidateFn(path);
                    }
                    
                    fs.watchFile(dirs[i], { interval: 1000 }, s);
                }
            }
            
            f.watchers = dirs;
            
            for(i = 0, c = f.listeners.length; i < c; i++) {
                f.listeners[i].fn(path, f.listeners[i].scope);
            }
        }
    },
    watch: function(p, scope, fn) {
        var i, c, s, f = this.files[p];
        
        if(f == null) {
            s = fs.statSync(p);
            
            if(s == null) {
                return;
            }
            
            f = { listeners: [ ], watchers: [ p ], dir: s.isDirectory() };
            this.files[p] = f;
            
            if(f.dir == true) {
                this.findAllSubdirectories(p, f.watchers);
            }
            
            s = this.invalidateFn(p);
            
            for(i = 0, c = f.watchers.length; i < c; i++) {
                fs.watchFile(f.watchers[i], { interval: 1000 }, s);
            }
        }
        
        f.listeners.push({ scope: scope, fn: fn });
    },
    unwatch: function(scope) {
        var f, i, c, k, l;
        
        if(scope != null) {
            var files = [ ];
            
            for(var file in this.files) {
                f = this.files[file].listeners;
                
                for(i = 0, c = f.length; i < c; i++) {
                    if(f[i].scope == scope) {
                        f.splice(i, 1);
                        
                        if(f.length == 0) {
                            files.push(file);
                        }
                        break;
                    }
                }
            }
            
            for(i = 0, c = files.length; i < c; i++) {
                f = this.files[files[i]].watchers;
                
                for(k = 0, l = f.length; k < l; k++) {
                    fs.unwatchFile(f[k]);
                }
                
                delete this.files[files[i]];
            }
        } else {
            for(var file in this.files) {
                f = this.files[file].watchers;
                
                for(k = 0, l = f.length; k < l; k++) {
                    fs.unwatchFile(f[k]);
                }
            }
            
            this.files = { };
        }
    }
};

var Cli = {
    executeCommandForApplication: function(name, cmd) {
        var app = State.app(name);
        
        if(app != null) {
            app[cmd].call(app);
        } else {
            State.log('Cannot find application "' + name + '"\n', true);
        }
    },
    executeCommand: function(cmd, app) {
        var i, c, app;
        
        State.lock();
        
        if(cmd == 'help') {
            process.stdout.write('Available commands:\n');
            process.stdout.write('  restart [app]\tStop and start\n');
            process.stdout.write('  start [app]\tStart\n');
            process.stdout.write('  start_watch [app]\tStart and watch\n');
            process.stdout.write('  stop [app]\t\n');
            process.stdout.write('  status\tThe current status\n');
            process.stdout.write('  exit\t\n');
        } else if(cmd == 'restart') {
            this.executeCommand('stop', app);
            this.executeCommand('start', app);
        } else if(cmd == 'status') {
            process.stdout.write('Status:\n');
            
            for(i = 0, c = State.config.apps.length; i < c; i++) {
                app = State.config.apps[i];
                process.stdout.write(
                    '  [' + ((State.apps[app.name] != null && State.apps[app.name].watching == true) ? '+' : '-') + '] ' +
                    app.name + '\t[' + ((State.apps[app.name] != null) ? State.apps[app.name].status : CONST.STATUS_STOPPED) + ']\n');
            }
        } else if(cmd == 'start' || cmd == 'start_watch' || cmd == 'stop') {
            if(app == null) {
                for(i = 0, c = State.config.apps.length; i < c; i++) {
                    this.executeCommandForApplication(State.config.apps[i].name, cmd);
                }
            } else {
                this.executeCommandForApplication(app, cmd);
            }
        } else if(cmd == 'exit') {
            for(i = 0, c = State.config.apps.length; i < c; i++) {
                app = State.config.apps[i];
                
                if(State.apps[app.name] != null) {
                    State.apps[app.name].stopProcess();
                }
            }
            
            process.exit(0);
        } else {
            process.stdout.write('Unknown command "' + cmd + '". Type "help" to learn more.\n');
        }
        
        State.unlock();
    }
};

var Config = {
    read: function(p) {
        try {
            var config = JSON.parse(fs.readFileSync(p, { encoding: 'utf8' }));
            var i, c;
            
            if(config.apps == null) {
                config.apps = [];
            }
            
            if(!(config.apps instanceof Array)) {
                throw '"apps" must be an array';
            }
            
            for(i = 0, c = config.apps; i < c; i++) {
                var app = config.apps[i];
                
                if(typeof(app) != 'object') {
                    throw 'app must be a dictionary';
                }
                
                if(typeof(app.name) != 'string') {
                    throw 'app "name" is invalid (' + JSON.stringify(app.name) + ')';
                }
                
                if(typeof(app.main) != 'string') {
                    throw 'app "main" is invalid (' + JSON.stringify(app.main) + ')';
                }
            }
            
            return config;
        }
        catch(e) {
            State.log('Unable to read "' + p + '":\n\t' + e + '\n', true);
        }
        
        return null;
    },
    monitor: function(p) {
        fs.watch(p, function(event) {
            if(event == 'change') {
                var config;
                
                State.log('Detected a configuration change...\n');
                
                if((config = Config.read(path)) != null) {
                    var i, c, app, apps = [ ];
                    
                    for(i = 0, c = State.config.apps.length; i < c; i++) {
                        app = State.apps[State.config.apps[i].name];
                        
                        if(app != null) {
                            if(app.status != CONST.STATUS_STOPPED) {
                                apps.push(State.config.apps[i].name);
                                app.stop();
                            }
                        }
                    }
                    
                    Monitor.unwatch();
                    State.apps = null;
                    State.config = config;
                    
                    for(i = 0, c = apps.length; i < c; i++) {
                        Cli.executeCommandForApplication(apps[i], 'start');
                    }
                }
            }
        });
    }
};

function Application(config) {
    var resolve = function(key, fallback) {
        return path.resolve(path.join(State.root,
            (State.config[key] && config[key]) ?
                path.join(State.config[key], config[key]) : (config[key] || State.config[key] || fallback)));
    };
    
    this.process = null;
    this.modules = config.modules || State.config.modules;
    this.options = config.options || State.config.options || '';
    this.sources = resolve('sources', 'src');
    this.binaries = resolve('binaries', 'build');
    this.resources = resolve('resources', path.join('lib', 'resources'));
    this.styles = resolve('styles', path.join('lib', 'styles'));
    this.templates = resolve('templates', path.join('lib', 'templates'));
    this.main = config.main;
    this.name = config.name;
    this.type = config.type || State.config.type || CONST.TYPE_SERVER;
    this.status = CONST.STATUS_STOPPED;
    this.watching = false;
    
    if(this.type == CONST.TYPE_CLI) {
        this.resources = null;
    }
    
    if(this.type == CONST.TYPE_API) {
        this.styles = null;
        this.templates = null;
    }
};

Application.prototype.compileOptions = function(options) {
    return CONST.HAXE_PATH +
        ((State.debug) ? ' -debug' : '') + 
        ' -js "' + path.join(this.binaries, this.name + '.js') + '"' +
        ' -lib saffron ' +
        options + ' ' + this.options + 
        ' -cp "' + this.sources + '"' +
        ' -main ' + this.main;
};

Application.prototype.linkModules = function(fn, modules) {
    var module = modules.shift();
    var that = this;
    
    if(!module) {
        fn(true);
        return;
    }
                    
    fs.exists(path.join(this.binaries, 'node_modules', module), function(exists) {
        if(exists) {
            that.linkModules(fn, modules);
        } else {
            State.exec(CONST.NPM_PATH + ' link ' + module, function(err, stdout, stderr) {
                if(err == null) {
                    if(stdout.length > 0) {
                        State.log(stdout + '\n');
                    }
                    
                    that.linkModules(fn, modules);
                } else {
                    State.log('\n\n' + stderr + '\n', true);
                    fn(false);
                }
            }, that.binaries);
        }
    });
}

Application.prototype.compileCode = function(fn) {
    var that = this;
    
    State.exec(
        this.compileOptions((this.type == CONST.TYPE_HYBRID) ? 
            '-lib nodejs -D nodejs -D server' :
            ((this.type == CONST.TYPE_CLI ||
              this.type == CONST.TYPE_SERVER ||
              this.type == CONST.TYPE_API) ? '-lib nodejs -D nodejs' : '-D client')), function(err, stdout, stderr) {
        if(err == null) {
            var modules = CONST.NODE_MODULES.slice(0);
            
            if(stdout.length > 0) {
                State.log(stdout + '\n');
            }
            
            if(that.modules != null && that.modules instanceof Array && that.modules.length > 0) {
                modules = modules.concat(that.modules);
            }
                  
            if(stdout.length > 0) {
                State.log(stdout + '\n');
            }
            
            if(that.type == CONST.TYPE_HYBRID) {
                State.exec(that.compileOptions('-D client'), function(err, stdout, stderr) {
                    if(err == null) {
                        that.linkModules(fn, modules);
                    } else {
                        State.log('\n\n' + stderr + '\n', true);
                        fn(false);
                    }
                });
            } else {
                that.linkModules(fn, modules);
            }
        } else {
            State.log('\n\n' + stderr + '\n', true);
            fn(false);
        }
    });
};

Application.prototype.compileResources = function(fn) {
    var s = (this.resources && fs.existsSync(this.resources)) ? fs.statSync(this.resources) : null;
    
    if(s != null && s.isDirectory()) {
        State.exec(
            'rsync -a ' +
            path.join(this.resources, '*') + ' ' +
            path.join(this.binaries, 'static', this.name) + ' ' +
            '--exclude=\'.*\'', function(err, stdout, stderr) {
            if(err == null) {
                if(stdout.length > 0) {
                    State.log(stdout);
                }
                
                fn(true);
            } else {
                State.log('\n\n' + stderr + '\n', true);
                fn(false);
            }
        });
    } else {
        fn(true);
    }
};

Application.prototype.compileStyles = function(fn) {
    var s = (this.styles && fs.existsSync(this.styles)) ? fs.statSync(this.styles) : null;
    
    if(s != null && s.isDirectory()) {
        State.exec(
            'cat "' + path.join(this.styles, '*.css') + '" > "' +
            path.join(this.binaries, 'static', this.name, 'stylesheet.css') + '"', function(err, stdout, stderr) {
            if(err == null) {
                if(stdout.length > 0) {
                    State.log(stdout);
                }
                
                fn(true);
            } else {
                State.log('\n\n' + stderr + '\n', true);
                fn(false);
            }
        });
    } else {
        fn(true);
    }
};

Application.prototype.compileTemplates = function(fn) {
    var s = (this.templates && fs.existsSync(this.templates)) ? fs.statSync(this.templates) : null;
    
    if(s != null && s.isDirectory()) {
        State.exec(
            'rsync -a ' +
            path.join(this.templates, '*') + ' ' +
            path.join(this.binaries, 'templates', this.name) + ' ' +
            '--exclude=\'.*\'', function(err, stdout, stderr) {
            if(err == null) {
                if(stdout.length > 0) {
                    State.log(stdout);
                }
                
                fn(true);
            } else {
                State.log('\n\n' + stderr + '\n', true);
                fn(false);
            }
        });
    } else {
        fn(true);
    }
};

Application.prototype.compile = function(fn) {
    var that = this;
    var styles = function(result) {
        if(result == true) {
            that.compileTemplates(fn);
        } else {
            fn(result);
        }
    };
    var resources = function(result) {
        if(result == true && that.type != CONST.TYPE_API) {
            that.compileStyles(styles);
        } else {
            fn(result);
        }
    };
    
    this.compileCode(function(result) {
        if(result == true && that.type != CONST.TYPE_CLI) {
            that.compileResources(resources);
        } else {
            fn(result);
        }
    });
};

Application.prototype.startProcess = function() {
    var that = this;
    
    State.log(this.name + ': started\n');
    this.process = child_process.spawn(process.argv[0], [ path.join(that.binaries, that.name + '.js') ], { cwd: State.root, env: process.env });
    this.process.stdout.addListener('data', function(data) {
        State.log(data, true);
    });
    this.process.stderr.addListener('data', function(data) {
        State.log(data, true);
    });
    this.process.addListener('exit', function(code) {
        State.log(that.name + ': Child process exited (' + code + ')\n', true);
        that.process = null;
        
        if(that.status == CONST.STATUS_STARTED) {
            that.status = (code == 0) ? CONST.STATUS_EXITED : CONST.STATUS_CRASHED;
        }
    });
};

Application.prototype.stopProcess = function() {
    if(this.process != null) {
        this.process.kill();
        this.process = null;
        State.log(this.name + ': stopped\n');
    }
};

Application.prototype.monitor = function(dir, compiler, comment) {
    var s = (dir && fs.existsSync(dir)) ? fs.statSync(dir) : null;
    var that = this;
    
    if(s != null && s.isDirectory()) {
        Monitor.watch(dir, this.name, function(p, s) {
            State.log('\r', true);
            State.lock();
            
            if(comment != null) {
                State.log(that.name + ': changed (' + comment + ')\n');
            }
            
            that.stopProcess();
            that.status = CONST.STATUS_BUILDING;
            
            that[compiler].call(that, function(result) {
                State.unlock();
                
                if(that.status == CONST.STATUS_BUILDING) {
                    if(result == true) {
                        that.status = CONST.STATUS_STARTED;
                        that.startProcess();
                    } else {
                        that.status = CONST.STATUS_ERROR;
                    }
                }
            });
        });
    }
};

Application.prototype.start = function() {
    this.start_watch(true);
};

Application.prototype.start_watch = function(nowatch) {
    if(this.status == CONST.STATUS_CRASHED || this.status == CONST.STATUS_EXITED) {
        this.status = CONST.STATUS_STARTED;
        this.startProcess();    
    } else if(this.status == CONST.STATUS_STOPPED) {
        var that = this;
        
        State.lock();
        
        if(nowatch != true) {
            this.monitor(this.sources, 'compileCode', 'sources');
            this.watching = true;
        }
        
        this.status = CONST.STATUS_BUILDING;
        
        this.compile(function(result) {
            if(result == true) {
                that.status = CONST.STATUS_STARTED;
                that.startProcess();
                
                if(nowatch != true) {
                    that.monitor(that.resources, 'compileResources', 'resources');
                    that.monitor(that.styles, 'compileStyles', 'styles');
                    that.monitor(that.templates, 'compileTemplates', 'templates');
                }
            } else {
                that.status = CONST.STATUS_ERROR;
            }
            
            State.unlock();
        });
    }
};

Application.prototype.stop = function() {
    if(this.status != CONST.STATUS_STOPPED) {
        Monitor.unwatch(this.name);
        this.status = CONST.STATUS_STOPPED;
        this.stopProcess();
        this.watching = false;
    }
};

var launchConfig = CONST.CONFIG_NAME;
var launchMode = CONST.MODE_HELP;
var launchArguments = [ ];

var parseState = 0;

process.argv.forEach(function(arg) {
    if(parseState == 0) {
        if(arg == '-c' || arg == '--config') {
            parseState = 1;
        } else if(arg == '--deploy') {
            State.debug = false;
        } else if(arg == '-h' || arg == '--help') {
            launchMode = CONST.MODE_HELP;
            parseState = 2;
        } else if(arg == '--version') {
            process.stdout.write(CONST.VERSION + '\n');
            process.exit(0);
        } else if(arg == CONST.MODE_MONITOR ||
                  arg == CONST.MODE_HELP ||
                  arg == CONST.MODE_COMPILE) {
            launchMode = arg;
            parseState = 2;
        }
    } else if(parseState == 1) {
        launchConfig = arg;
        parseState = 0;
    } else if(parseState == 2) {
        launchArguments.push(arg);
    }
});

if(launchMode == null) {
    process.stdout.write('Unknown launch mode\n');
    process.exit(1);
} else if(launchMode == CONST.MODE_HELP) {
    process.stdout.write('\nUsage:\n');
    process.stdout.write('  saffron -c config.json monitor\n');
    process.stdout.write('  saffron monitor start\n\n');
    process.stdout.write('Launch options:\n');
    process.stdout.write('  -c PATH\tConfig file\n');
    process.stdout.write('  --verbose\tVerbose mode\n');
    process.stdout.write('  --deploy\tDeployment mode\n');
    process.stdout.write('  --version\tPrint version\n\n');
    process.stdout.write('Available commands:\n');
    process.stdout.write('  compile [app]\n');
    process.stdout.write('  monitor [action] [app]\n');
    process.stdout.write('  help\n\n');
    process.exit(0);
} else if((State.config = Config.read(launchConfig)) != null) {
    State.root = path.dirname(path.resolve(launchConfig));
    
    if(launchMode == CONST.MODE_MONITOR) {
        process.stdin.resume();
        process.stdin.setEncoding('utf8');
        
        process.stdin.on('data', function(chunk) {
            if(State.depth == 0) {
                var cmd = chunk.toString().replace(/^\s+|\s+$/g, '').split(' ');
                
                if(cmd[0].length > 0) {
                    Cli.executeCommand(cmd[0], (cmd.length > 1) ? cmd[1] : null);
                }
            }
        });
        
        process.on('SIGINT', function() {
            Cli.executeCommand('exit', null);
        });
        
        Cli.executeCommand((launchArguments.length > 0) ? launchArguments[0] : 'start_watch',
                           (launchArguments.length > 1) ? launchArguments[1] : null);
        Config.monitor(launchConfig);
    } else if(launchMode == CONST.MODE_COMPILE) {
        var name = (launchArguments.length > 0) ? launchArguments[0] : null;
        var i, c, app, exitcode = 0, counter = 0;
        
        for(i = 0, c = State.config.apps.length; i < c; i++) {
            app = new Application(State.config.apps[i]);
            
            if(name == null || app.name == name) {
                counter += 1;
                app.compile(function(result) {
                    counter -= 1;
                    
                    if(result == false) {
                        exitcode = 1;
                    }
                    
                    if(counter == 0) {
                        process.exit(exitcode);
                    }
                });
            }
        }
    }
}
