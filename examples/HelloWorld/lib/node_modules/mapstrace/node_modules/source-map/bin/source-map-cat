#!/usr/bin/env node

var fs = require('fs');
var buffer = require('buffer');
var SourceMapGenerator = require('source-map').SourceMapGenerator;

/**
 * Parse the files and arguments from the command line.
 *
 * @param argv The array of arguments from the command line.
 * @return An object with two properties: "args" and "options".
 */
function parseArgs(argv) {
  var options = {
    output: null,
    sourceMap: null
  };
  var args = [];

  while (argv.length > 0) {
    var a = argv.shift();
    if (a[0] === '-') {
      switch (a) {
      case '-l':
      case '--literal':
        args.push(new Literal(argv.shift()));
        break;
      case '-o':
      case '--output':
        options.output = fs.openSync(argv.shift(), 'w');
        break;
      case '-s':
      case '--source-map':
        options.sourceMap = fs.openSync(argv.shift(), 'w');
        break;
      default:
        throw new Error("Unknown option: " + a);
        break;
      }
    }
    else {
      args.push(new File(a));
    }
  }

  if (!options.sourceMap) {
    throw new Error('-s argument is required.');
  }

  if (!options.output) {
    throw new Error('-o argument is required.');
  }

  return {
    args: args,
    options: options
  };
}

/**
 * Wrapper around file descriptors which allows us to get one line at a time.
 */
function File(filepath) {
  this._fd = fs.openSync(filepath, 'r');
  this._data = "";
  this._eof = false;
  this.filepath = filepath;
}

File.prototype.getLine = function File_getLine() {
  var chunk;
  var numRead;
  var result;

  if (this._eof && this._data === "") {
    return null;
  }

  var idx = this._data.length;
  while (this._data.indexOf('\n') === -1) {
    idx = this._data.length;
    result = fs.readSync(this._fd, 1024, 'utf-8');
    chunk = result[0];
    numRead = result[1];

    if (numRead === 0) {
      fs.closeSync(this._fd);
      this._eof = true;
      break;
    }

    this._data += chunk;
  }

  var line = this._data.split('\n')[0] + '\n';
  this._data = this._data.split('\n').slice(1).join('\n');

  return line;
};

/**
 * Wraps literal strings so that we can get one line at a time.
 */
function Literal(literal) {
  this._lines = literal.split('\n').map(function (line) {
    return line + '\n';
  });
}

Literal.prototype.getLine = function Literal_getLine() {
  if (this._lines.length === 0) {
    return null;
  }

  return this._lines.shift();
};

/**
 * Main function.
 */
function main() {
  var parsed = parseArgs(process.argv.slice(2));
  var map = new SourceMapGenerator({
    file: parsed.options.output
  });
  var generatedLine = 0;

  parsed.args.forEach(function (a, i) {
    var line;
    var lineNo = 0;

    while ((line = a.getLine()) !== null) {
      lineNo++;
      generatedLine++;

      fs.writeSync(parsed.options.output, line);

      if (a.filepath) {
        map.addMapping({
          source: a.filepath,
          generated: { line: lineNo, column: 0 },
          original: { line: generatedLine, column: 0 }
        });
      }
      else {
        map.addMapping({
          source: null,
          generated: { line: generatedLine, column: 0 }
        });
      }
    }
  });

  fs.writeSync(parsed.options.sourceMap, map.toString());
}

if (module.parent == null) {
  main();
}
